/* esm.sh - esbuild bundle(@noble/hashes@1.3.3/utils) es2021 production */
import{crypto as f}from"./crypto.js";var L=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),_=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4));function u(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}var m=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),U=(t,e)=>t<<32-e|t>>>e,a=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!a)throw new Error("Non little-endian hardware is not supported");var g=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function E(t){if(!u(t))throw new Error("Uint8Array expected");let e="";for(let o=0;o<t.length;o++)e+=g[t[o]];return e}var c={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function l(t){if(t>=c._0&&t<=c._9)return t-c._0;if(t>=c._A&&t<=c._F)return t-(c._A-10);if(t>=c._a&&t<=c._f)return t-(c._a-10)}function O(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);let e=t.length,o=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);let n=new Uint8Array(o);for(let r=0,i=0;r<o;r++,i+=2){let p=l(t.charCodeAt(i)),d=l(t.charCodeAt(i+1));if(p===void 0||d===void 0){let y=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+y+'" at index '+i)}n[r]=p*16+d}return n}var x=async()=>{};async function k(t,e,o){let n=Date.now();for(let r=0;r<t;r++){o(r);let i=Date.now()-n;i>=0&&i<e||(await x(),n+=i)}}function b(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function s(t){if(typeof t=="string"&&(t=b(t)),!u(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function B(...t){let e=0;for(let n=0;n<t.length;n++){let r=t[n];if(!u(r))throw new Error("Uint8Array expected");e+=r.length}let o=new Uint8Array(e);for(let n=0,r=0;n<t.length;n++){let i=t[n];o.set(i,r),r+=i.length}return o}var w=class{clone(){return this._cloneInto()}},h={}.toString;function T(t,e){if(e!==void 0&&h.call(e)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(t,e)}function j(t){let e=n=>t().update(s(n)).digest(),o=t();return e.outputLen=o.outputLen,e.blockLen=o.blockLen,e.create=()=>t(),e}function V(t){let e=(n,r)=>t(r).update(s(n)).digest(),o=t({});return e.outputLen=o.outputLen,e.blockLen=o.blockLen,e.create=n=>t(n),e}function S(t){let e=(n,r)=>t(r).update(s(n)).digest(),o=t({});return e.outputLen=o.outputLen,e.blockLen=o.blockLen,e.create=n=>t(n),e}function D(t=32){if(f&&typeof f.getRandomValues=="function")return f.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}export{w as Hash,k as asyncLoop,E as bytesToHex,T as checkOpts,B as concatBytes,m as createView,O as hexToBytes,a as isLE,x as nextTick,D as randomBytes,U as rotr,s as toBytes,_ as u32,L as u8,b as utf8ToBytes,j as wrapConstructor,V as wrapConstructorWithOpts,S as wrapXOFConstructorWithOpts};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=utils.js.map