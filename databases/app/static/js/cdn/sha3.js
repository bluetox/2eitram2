/* esm.sh - esbuild bundle(@noble/hashes@1.3.3/sha3) es2021 production */
import{bytes as X,exists as w,number as O,output as N}from"./_assert.js";var d=BigInt(4294967295),k=BigInt(32);function F(s,t=!1){return t?{h:Number(s&d),l:Number(s>>k&d)}:{h:Number(s>>k&d)|0,l:Number(s&d)|0}}function L(s,t=!1){let n=new Uint32Array(s.length),e=new Uint32Array(s.length);for(let r=0;r<s.length;r++){let{h:i,l:o}=F(s[r],t);[n[r],e[r]]=[i,o]}return[n,e]}var _=(s,t,n)=>s<<n|t>>>32-n,g=(s,t,n)=>t<<n|s>>>32-n,I=(s,t,n)=>t<<n-32|s>>>64-n,B=(s,t,n)=>s<<n-32|t>>>64-n;import{Hash as E,u32 as M,toBytes as P,wrapConstructor as C,wrapXOFConstructorWithOpts as R}from"./utils.js";var[y,A,S]=[[],[],[]],j=BigInt(0),f=BigInt(1),W=BigInt(2),q=BigInt(7),v=BigInt(256),z=BigInt(113);for(let s=0,t=f,n=1,e=0;s<24;s++){[n,e]=[e,(2*n+3*e)%5],y.push(2*(5*e+n)),A.push((s+1)*(s+2)/2%64);let r=j;for(let i=0;i<7;i++)t=(t<<f^(t>>q)*z)%v,t&W&&(r^=f<<(f<<BigInt(i))-f);S.push(r)}var[D,G]=L(S,!0),H=(s,t,n)=>n>32?I(s,t,n):_(s,t,n),b=(s,t,n)=>n>32?B(s,t,n):g(s,t,n);function J(s,t=24){let n=new Uint32Array(10);for(let e=24-t;e<24;e++){for(let o=0;o<10;o++)n[o]=s[o]^s[o+10]^s[o+20]^s[o+30]^s[o+40];for(let o=0;o<10;o+=2){let c=(o+8)%10,u=(o+2)%10,a=n[u],l=n[u+1],T=H(a,l,1)^n[c],U=b(a,l,1)^n[c+1];for(let p=0;p<50;p+=10)s[o+p]^=T,s[o+p+1]^=U}let r=s[2],i=s[3];for(let o=0;o<24;o++){let c=A[o],u=H(r,i,c),a=b(r,i,c),l=y[o];r=s[l],i=s[l+1],s[l]=u,s[l+1]=a}for(let o=0;o<50;o+=10){for(let c=0;c<10;c++)n[c]=s[o+c];for(let c=0;c<10;c++)s[o+c]^=~n[(c+2)%10]&n[(c+4)%10]}s[0]^=D[e],s[1]^=G[e]}n.fill(0)}var x=class s extends E{constructor(t,n,e,r=!1,i=24){if(super(),this.blockLen=t,this.suffix=n,this.outputLen=e,this.enableXOF=r,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,O(e),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=M(this.state)}keccak(){J(this.state32,this.rounds),this.posOut=0,this.pos=0}update(t){w(this);let{blockLen:n,state:e}=this;t=P(t);let r=t.length;for(let i=0;i<r;){let o=Math.min(n-this.pos,r-i);for(let c=0;c<o;c++)e[this.pos++]^=t[i++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:t,suffix:n,pos:e,blockLen:r}=this;t[e]^=n,n&128&&e===r-1&&this.keccak(),t[r-1]^=128,this.keccak()}writeInto(t){w(this,!1),X(t),this.finish();let n=this.state,{blockLen:e}=this;for(let r=0,i=t.length;r<i;){this.posOut>=e&&this.keccak();let o=Math.min(e-this.posOut,i-r);t.set(n.subarray(this.posOut,this.posOut+o),r),this.posOut+=o,r+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return O(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(N(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){let{blockLen:n,suffix:e,outputLen:r,rounds:i,enableXOF:o}=this;return t||(t=new s(n,e,r,o,i)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=i,t.suffix=e,t.outputLen=r,t.enableXOF=o,t.destroyed=this.destroyed,t}},h=(s,t,n)=>C(()=>new x(t,s,n)),Z=h(6,144,224/8),$=h(6,136,256/8),tt=h(6,104,384/8),st=h(6,72,512/8),nt=h(1,144,224/8),ot=h(1,136,256/8),et=h(1,104,384/8),rt=h(1,72,512/8),m=(s,t,n)=>R((e={})=>new x(t,s,e.dkLen===void 0?n:e.dkLen,!0)),it=m(31,168,128/8),ct=m(31,136,256/8);export{x as Keccak,J as keccakP,nt as keccak_224,ot as keccak_256,et as keccak_384,rt as keccak_512,Z as sha3_224,$ as sha3_256,tt as sha3_384,st as sha3_512,it as shake128,ct as shake256};
//# sourceMappingURL=sha3.js.map